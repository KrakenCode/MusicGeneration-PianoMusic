#
# Code to create a midi file from the notes/chords list
#

from music21 import instrument, note, stream, chord
import numpy as np
from train_model import get_tokenized_notes, clean_lines
import train_model as md
import sys
import os
import random

MAXLEN = 5

'''
Takes a list of music elements from the output of the model and converts them 
to rest, chord or note objects. Places the objects in a list and returns them 
to be converted to a midi file.
'''
def create_music_objects(model_output):
    song_offset = 0
    music_objects = []  # a list of music objects; rest, chord or note
    
    # split the output of the model on spaces and remove spaces
    music_list = model_output.split(' ')
    music_list = [a for a in music_list if a != '' and a != ' ']
    
    # create note and chord objects based on the values generated by the model
    for music_element in music_list:
        # music element is a rest
        if 'rest' in music_element:
            new_rest = note.Rest()
            new_rest.offset = song_offset
            music_objects.append(new_rest)
        # music element is a chord
        elif '|' in music_element:
            notes_in_chord = music_element.split('|')
            notes = []
            for current_note in notes_in_chord:
                new_note = note.Note(current_note)
                new_note.storedInstrument = instrument.Piano()
                notes.append(new_note)
            new_chord = chord.Chord(notes)
            new_chord.offset = song_offset
            music_objects.append(new_chord)
        # music element is a note
        else:
            new_note = note.Note(music_element)
            new_note.offset = song_offset
            new_note.storedInstrument = instrument.Piano()
            music_objects.append(new_note)

        # increase offset each iteration so that notes do not stack
        song_offset += 0.5
    
    return music_objects

'''
Write the list of music objects as a midi stream to the given file name.
'''
def write_to_file(music_objects, file_name):
    midi_stream = stream.Stream(music_objects)
    midi_stream.write('midi', fp=file_name)



'''

'''
def generate(primer_list, ctable, model):
    
    questions = primer_list

    x = np.zeros((len(questions), MAXLEN, len(ctable.chars)), dtype=np.bool)
    for i, sentence in enumerate(questions):
        x[i] = ctable.encode(sentence, MAXLEN)
    preds = model.predict_classes(x)
    new_song = []   # TODO make sure tmp was the new song
    for xrow in preds:
        new_song.append(ctable.decode(xrow, calc_argmax=False))
    
    return new_song

'''

'''    
def generate_long(note_sequence, ctable, model, length=5):
    #lines = open(primer_file).readlines()
    #cl = clean_lines(lines)
    #primer_list = ' '.join(cl[0])
    #last = cl[-1]
    #primer_list = ' '.join(note_sequence[0])
    #last = note_sequence[-1]
    last = note_sequence.split(' ')
    for i in range(length):
        last = generate([last], ctable, model)[0]
        note_sequence += ' ' + last
        last = last.split(' ')
    return note_sequence

'''
Selects a random five note starting sequence from
either the answers.txt or questions.txt files
'''
def select_random_note_sequence():
    if "answers.txt" in os.listdir():
        notes = open("answers.txt").readlines()
    elif "questions.txt" in os.listdir():
        notes = open("questions.txt").readlines()        
    else:
        print("Need answers.txt or questions.txt to select random starting note sequence. Exiting... ")
        print("Usage: create_dataset.py path_to_midi_files")
    
    note_sequence = random.choice(notes)
    note_sequence = note_sequence.rstrip()        
    return note_sequence
        
        

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: " + sys.argv[0] + " model_name\n")
        sys.exit(1)
    
    model_name = sys.argv[1]

    if model_name not in os.listdir():
        print("Must run train_model.py before generating. Exiting...")
        print("Usage: train_model.py model_name")
        sys.exit(1)
        
    x, y, ctable, chars = md.prepare_dataset()
    model = md.build_model(len(chars))
    model.load_weights(model_name)
    note_sequence = select_random_note_sequence()
    new_song = generate_long(note_sequence, ctable, model, 20)
    music_objects=create_music_objects(new_song)
    write_to_file(music_objects, "test.midi") # hard coded midi name